// Author: cvet, heX, Тринитротолуол, Tab10id
#include "_macros.fos"
#include "stdlib_h.fos"

// Возвращает размер группы (живых ее участников)
// размер береться вне зависимости от того лидер это или просто партиец

import void FlushScreen( Critter& cr, bool fadeOut, uint timeMs ) from "effects";
import bool AddWalkPlane( Critter& npc, uint priority, uint16 hexX, uint16 hexY, uint8 dir, bool run, uint cut ) from "npc_planes";

int DFGroupCount( Critter& player, Critter@ npc )
{
    Critter @ leader;
    if( not valid( player.GetFollowLeader() ) ) // если у игрока нет лидера
        @leader = player;                       // тогда считаем что он и есть лидер
    else
        @leader = player.GetFollowLeader();     // иначе берем лидера

    Critter@[] groups;
    groups.insertLast( @leader );
    leader.GetFollowGroup( FIND_LIFE, groups );
    return groups.length();
}

// !/ Размер группы больше >=VAL
bool d_GroupCountMore( Critter& player, Critter@ npc, int val )
{
    return DFGroupCount( player, npc ) >= val;
}

bool d_GroupCountLess( Critter& player, Critter@ npc, int val )
{
    return DFGroupCount( player, npc ) < val;
}

// !/ У всех уровень больше >=VAL
// Проверка что все игроки в группе больше или равны указанному уровню.
bool d_GroupLevelMore( Critter& player, Critter@ npc, int val )
{
    Critter@[] groups;
    groups.insertLast( @player );
    player.GetFollowGroup( FIND_LIFE, groups );
    for( uint i = 0; i < groups.length(); i++ )
        if( groups[ i ].Stat[ ST_LEVEL ] < val ) // если хотябы один из них меньше требуемого уровня
            return false;
    return true;
}

bool d_GroupLevelLess( Critter& player, Critter@ npc, int val )
{
    Critter@[] groups;
    groups.insertLast( @player );
    player.GetFollowGroup( FIND_LIFE, groups );
    for( uint i = 0; i < groups.length(); i++ )
        if( groups[ i ].Stat[ ST_LEVEL ] > val ) // если хотябы один из них меньше требуемого уровня
            return false;
    return true;
}

// Игрок нуждаеться в лечении?
bool d_IsToHeal( Critter& player, Critter@ npc )
{
    return player.Stat[ ST_CURRENT_HP ] < player.Stat[ ST_MAX_LIFE ];
}

// Игроку известна эта локация?
bool d_IsLocationVisible( Critter& player, Critter@ npc, int LocNum )
{
    return player.IsKnownLoc( false, uint16( LocNum ) );
}

// Игроку НЕ известна эта локация?
bool d_IsLocationNotVisible( Critter& player, Critter@ npc, int LocNum )
{
    return not player.IsKnownLoc( false, uint16( LocNum ) );
}

// Есть зависимости от наркотиков?
bool d_IsAddict( Critter& player, Critter@ npc )
{
    for( uint i = ADDICTION_BEGIN; i <= ADDICTION_END; i++ )
        if( player.Addiction[ i ] != 0 )
            return true;
    return false;
}

// У игрока нет зависимостей от наркотиков?
bool d_IsNotAddict( Critter& player, Critter@ npc )
{
    return not d_IsAddict( player, npc );
}

// Игрок в группе? (лидер тоже считаеться)
bool d_GroupPresent( Critter& player, Critter@ npc )
{
    return DFGroupCount( player, npc ) > 1;
}

// Игрок НЕ в группе? (лидер тоже считаеться)
bool d_NotGroupPresent( Critter& player, Critter@ npc )
{
    return not d_GroupPresent( player, npc );
}

/** проверка на таймаут
   используйте функцию r_TimeoutSet для инициализации
   если таймаут кончился (или еще и не начинался)
   то функция вернет истинну (разрешит ответ)
   иначе вернет ложь (ответ будет скрыт)
 */
bool d_TimeoutCheck( Critter& player, Critter@ npc )
{
    GameVar @ t = GetLocalVar( LVAR_timeout, npc.Id );
    if( not valid( t ) )
        return true;         // таймаут еще и не начался
    if( __FullSecond >= uint( t.GetValue() ) )
        return true;         // таймаут истек
    else
        return false;        // таймаут еще жив
}

/**
        инверсия d_TimeoutCheck
 */
bool d_NotTimeoutCheck( Critter& player, Critter@ npc )
{
    return not d_TimeoutCheck( player, npc );
}


// Проверка уникальной переменной - таймаута игрок-нпц
// Время прошло, или таймаут не назначался
bool d_TimeoutOk( Critter& player, Critter @ npc )
{
    if( !valid( npc ) )
        return false;
    GameVar @ to = GetUnicumVar( UVAR_uniq_timeout, player.Id, npc.Id );
    if( !valid( to ) )
        return false;
    uint time = to.GetValue();
    if( time == 0 )
        return true;
    return ( time < __FullSecond );
}

// Таймаут не закончился
bool d_NotTimeoutOk( Critter& player, Critter @ npc )
{
    return !d_TimeoutOk( player, npc );
}

bool d_CheckMonth( Critter& playe, Critter @npc, int monthFrom, int monthTo )
{
    return ( int(__Month) <= monthTo && int(__Month) >= monthFrom );
}

// НПЦ жив?
// в v0 указываем NpcRole НПЦ (на карте должен быть в 1 экземпляре)
// в v1 указываем PID карты (карта должна быть в игре в одном экземпляре)
bool d_IsLife( Critter& player, Critter@ npc, int v0, int v1 )
{
    Map @ map = GetMapByPid( v1, 0 );
    if( not valid( map ) )
    {
        Log( "error" );
        return false;
    }
    Critter @ crit = map.GetNpc( v0, FIND_ALL | FIND_ONLY_NPC, 0 );
    if( not valid( crit ) )
    {
        Log( "error" );
        return false;
    }
    if( crit.IsLife() )
        return true;
    else
        return false;
}

// НПЦ мертв?
bool d_IsDead( Critter& player, Critter@ npc, int v0, int v1 )
{
    return not d_IsLife( player, npc, v0, v1 );
}

void dlg_ForSearching( Critter& player, Critter@ barman, string@ playerName )
{
    if( !valid( barman ) )
        return;
    if( !IS_DIALOG_SAY_MODE( playerName ) || IS_DIALOG_END( playerName ) )
        return;
    if( playerName.length() <= 1 )
        return;
    uint   BankerDialog = barman.Stat[ ST_DIALOG_ID ];
    uint   DlgStr = 200;
    // Имя запрашиваемого криттера и инициализация переменной с лексемами.
    string lexems = "$Victim " + playerName;
    // Пол бармена.
    if( barman.Stat[ ST_GENDER ] == GENDER_FEMALE )
    {
        lexems += "$BarmanGen @msg dlg " + DLGSTR( BankerDialog, DlgStr + 10 ) + "@";
    }
    else
    {
        lexems += "$BarmanGen @msg dlg " + DLGSTR( BankerDialog, DlgStr + 9 ) + "@";
    }
    // Игрок не найден.
    Critter@ cr = GetPlayer( playerName );
    if( !valid( cr ) )
    {
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 0 ), lexems );
        return;
    }
    // Пол запрашиваемого криттера.
    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
    {
        lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 8 ) + "@";
    }
    else
    {
        lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 7 ) + "@";
    }
    player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 11 ), lexems );
    return;
}

void dlg_TrySearching( Critter& player, Critter@ barman, string@ playerName )
{

    #define LOC_NAME    # (mapId)                       ( ( mapId + 100 ) * 1000 ) // поиск названия локации в файле FOGM.msg
    if( !valid( barman ) )
        return;
    if( !IS_DIALOG_SAY_MODE( playerName ) || IS_DIALOG_END( playerName ) )
        return;
    if( playerName.length() <= 1 )
        return;
    uint   BankerDialog = barman.Stat[ ST_DIALOG_ID ];
    uint   DlgStr = 200;
    // Имя запрашиваемого криттера и инициализация переменной с лексемами.
    string lexems = "$Victim " + playerName;
    // Пол бармена.
    if( barman.Stat[ ST_GENDER ] == GENDER_FEMALE )
    {
        lexems += "$BarmanGen @msg dlg " + DLGSTR( BankerDialog, DlgStr + 10 ) + "@";
    }
    else
    {
        lexems += "$BarmanGen @msg dlg " + DLGSTR( BankerDialog, DlgStr + 9 ) + "@";
    }
    // Игрок не найден.
    Critter@ cr = GetPlayer( playerName );
    if( !valid( cr ) )
    {
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 0 ), lexems );
        return;
    }
    // Пол запрашиваемого криттера.
    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
    {
        lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 8 ) + "@";
    }
    else
    {
        lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 7 ) + "@";
    }
    // Игрок спрашивает о самом себе.
    if( player.Id == cr.Id )
    {
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 1 ) );
        return;
    }
    // Криттер на глобале.
    Map@ map = cr.GetMap();
    if( !valid( map ) )
    {
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 2 ), lexems );
        return;
    }
    // Локация, где находится криттер. Диапазоны PID: до 150 и 210-235. Города и репликации.
    if( cr.GetMap().GetLocation().GetProtoId() < 50 || cr.GetMap().GetLocation().GetProtoId() >= 200 )
    {
        lexems += "$Place @msg GM " + LOC_NAME( cr.GetMap().GetLocation().GetProtoId() ) + "@";
        // Криттер находится в той же локации, что и игрок.
        if( barman.GetMap().GetLocation().Id == cr.GetMap().GetLocation().Id )
        {
            player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 3 ), lexems );
            return;
        }
        // Криттер найден, лексемы сформированы - даем информацию.
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 4 + Random( 0, 2 ) ), lexems );
    }
    else
    {
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 2 ), lexems );
        return;
    }
}

void r_ToHeal( Critter& player, Critter@ npc )
{
    HealCritter( player );
}

void r_DropDrugs( Critter& player, Critter @ npc )
{
    DropDrugEffects( player );
}

void r_DropRadiation( Critter& player, Critter @ npc )
{
    DropRadiation( player );
}

void r_ShowLocation( Critter& player, Critter@ npc, int locNum )
{
    player.SetKnownLoc( false, uint16( locNum ) );
}

void r_FadeOut( Critter& player, Critter@ npc, int time )
{
    if( time == 0 )
        time = 2000;
    FlushScreen( player, false, time );
}

void r_MoveAfterCloseDialog(Critter& player, Critter@ npc, int _hexX, int _hexY, int _dir, int _run, int _cut) 
{	
	if (npc.Mode[ MODE_NO_WALK ] == 1)
	{
		npc.ModeBase[ MODE_NO_WALK ] = 0;
	}
	// bool AddWalkPlane( Critter& npc, uint priority, uint16 hexX, uint16 hexY, uint8 dir, bool run, uint cut )
	uint16 hexX = _hexX;
	uint16 hexY = _hexY;
	uint8 dir = _dir;
	bool run = _run == 0 ? false : true;
	uint cut = _cut;
	AddWalkPlane(npc, 1, hexX, hexY, dir, run, cut);
	npc.SetHomePos( hexX, hexY, dir );
}

void r_TransitToGlobal( Critter& player, Critter@ npc )
{
    player.TransitToGlobal( false );
}

void r_TransitToLocation( Critter& player, Critter@ npc, int locPid, int mapIndex )
{
    TransitToLoc( player, locPid, mapIndex, 0 );
}

void r_TransitToMap( Critter& player, Critter@ npc, int mapPid, int entranceNum )
{
    TransitToMap( player, mapPid, entranceNum );
}

void r_InfoMessage( Critter& player, Critter@ npc, int strNum )
{
    InfoMessage( player, npc, strNum );
}

// Установка таймаута в часах на отдельного нпц (общий для всех игроков).
void r_TimeoutSet( Critter& player, Critter@ npc, int gameHours )
{
    if( valid( npc ) )
        TimeoutSet( npc, gameHours );
}

// Установка таймаута в минутах для связки игрок/нпц.
void r_SetUniqTO( Critter& player, Critter @ npc, int value )
{
    if( !valid( npc ) )
        return;
    GameVar @ to = GetUnicumVar( UVAR_uniq_timeout, player.Id, npc.Id );
    if( !valid( to ) )
        return;
    to = value * 60 + __FullSecond;
}

void r_DoorOpen( Critter& player, Critter@ npc, int entireNum )
{
    DoorControl( player, entireNum, true );
}

void r_DoorClose( Critter& player, Critter@ npc, int entireNum )
{
    DoorControl( player, entireNum, false );
}

// Даем игроку голодиск
void r_GiveHolodisk( Critter& player, Critter@ npc, int holodiskNum )
{
    Item@ holo = player.AddItem( PID_HOLODISK, 1 );
    holo.HolodiskNumber = holodiskNum;
    holo.Update();
}

void r_Attack( Critter& player, Critter@ npc, int npcRole )
{
    Attack( player, npcRole );
}

void r_AttackStop( Critter& player, Critter@ npc, int npcRole )
{
    AttackStop( player, npcRole );
}

void r_Kill( Critter& player, Critter@ npc, int type )
{
    Kill( player, type );
}

void r_Damage( Critter& player, Critter@ npc, int dmg, int type, int dir )
{
    Damage( player, dmg, type, dir );
}

// Атака игрока всеми НПЦ на карте, у которых команда совпадает с командой говорящего НПЦ
void r_TeamAttack( Critter& player, Critter@ npc )
{
    if( !valid( npc ) )
        return;
    Map@ map = npc.GetMap();
    if( !valid( map ) )
        return;
    Critter@[] team;
    if( map.GetCritters( 0, FIND_LIFE | FIND_ONLY_NPC, team ) > 0 )
    {
        for( uint i = 0, l = team.length(); i < l; i++ )
        {
            if( team[ i ].Stat[ ST_TEAM_ID ] == npc.Stat[ ST_TEAM_ID ] )
                AddAttackPlane( team[ i ], 0, player.Id );
        }
    }
}

// Отложенная всплывающая строка над нпц
void r_SayMessageDelayed( Critter& player, Critter @ npc, int strNum, int delaySeconds, int sayType )
{
    if( !valid( npc ) )
        return;
    uint[] values = { npc.Id, uint( sayType ), uint( strNum ) };
    CreateTimeEvent( __FullSecond + delaySeconds, "e_SayMessage", values, false );
}

uint e_SayMessage( uint[] @ values )
{
    if( values.length() < 3 )
        return 0;
    Critter @ cr = GetCritter( values[ 0 ] );
    if( !valid( cr ) )
        return 0;
    int did = cr.Stat[ ST_DIALOG_ID ];
    if( did == 0 )
        return 0;
    cr.SayMsg( values[ 1 ], TEXTMSG_DLG, DLGSTR( did, values[ 2 ] ) );
    return 0;
}

void r_SkillUp( Critter& player, Critter@ npc, int skill )
{
    SkillUp( player, skill );
}

void r_QuestReward( Critter& player, Critter@ npc, int base )
{
    QuestRewardExperience( player, base );
}

void r_QuestReward1( Critter& player, Critter@ npc )
{
    int base = 10;
    if( player.Stat[ ST_LEVEL ] < 20 )
        base = 15;
    if( player.Stat[ ST_LEVEL ] < 10 )
        base = 20;
    if( player.Stat[ ST_LEVEL ] < 5 )
        base = 40;
    QuestRewardExperience( player, base );
}

void r_QuestReward2( Critter& player, Critter@ npc )
{
    int base = 15;
    if( player.Stat[ ST_LEVEL ] < 20 )
        base = 20;
    if( player.Stat[ ST_LEVEL ] < 10 )
        base = 50;
    QuestRewardExperience( player, base );
}

void r_QuestReward3( Critter& player, Critter@ npc )
{
    int base = 35;
    if( player.Stat[ ST_LEVEL ] < 20 )
        base = 45;
    if( player.Stat[ ST_LEVEL ] < 10 )
        base = 60;
    QuestRewardExperience( player, base );
}


bool d_NotLocationKnown( Critter& player, Critter@ npc, int locPid )
{
    return !player.IsKnownLoc( false, uint( locPid ) );
}
void r_CreateLocation( Critter& player, Critter@ npc, int locPid, int worldX, int worldY, int dayDelete, int varNum )
{
    // Создает локацию в радиусе двух зон от заданных координат
    int       delta = __GlobalMapZoneLength * 2;
    Location@ loc = CreateLocationForCritter( player, locPid, worldX, worldY, delta, varNum );
    if( valid( loc ) )
        SetLocationDeleteTime( loc, 60 * 60 * 24 * dayDelete );
}
