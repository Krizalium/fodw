#define	REL_HATE	(1)
#define	REL_DISLIKE	(2)
#define	REL_NEUTRAL	(3)
#define	REL_LIKE	(4)
#define	REL_IDOL	(5)

void main_critter_attacked(Critter& victim, Critter& attacker)
{
	Critter@[] nearbyCritters;
		victim.GetCritters (true, FIND_LIFE_AND_KO | FIND_ONLY_NPC, nearbyCritters);
		
    uint victimTeamId = victim.Stat[ST_TEAM_ID];
    uint attackerTeamId = attacker.Stat[ST_TEAM_ID];

	if (victim.IsPlayer())
	{
		// В зависимости от локации, пытаемся защитить, если репа не отрицательна. 
	}
	else
	{
		// Всегда пытаемся дать сдачи: // или может сначала просим прекратить при хорошем отношении? 
		AddAttackPlane (victim, 0, attacker);
		// Бьют NPC, если в городе, то защищаем ВСЕГДА. 
		
		// Если просто бьют, зовем ближних, если убийство, то зовем всех. 
		// Исключение для мобов. 
		
		if (victimTeamId == attackerTeamId) // friendly fire
		{
			// todo: Сказать что-то вроде "Какого хера ты по мне лупишь?".
			Log ("friendly fire");
			return;
		}
	}
	
	for (uint i = 0, j = nearbyCritters.length(); i < j; i++)
	{
		Critter@ nearbyCr = nearbyCritters[i];
		if (!valid(nearbyCr)) continue;
		
		uint8 relToVictim = 0;//GetRelationshipForNearbyCritter (nearbyCr, victim); // Как относится к жертве?
		uint8 relToAttacker = 0;//GetRelationshipForNearbyCritter (nearbyCr, attacker);
		
		
		if (attackerTeamId == TEAM_Player || attackerTeamId < 100 || attackerTeamId < 100		/* Или мобы */)
		{
			
			/* hate victim */
			if (relToVictim == REL_HATE && relToAttacker == REL_HATE)
			{
				AddAttackPlane (nearbyCr, 0, attacker);
				AddAttackPlane (nearbyCr, 0, victim);
			}
			if (relToVictim == REL_HATE && relToAttacker == REL_DISLIKE)
			{
				if (attacker.Stat[ST_CURRENT_HP] <= attacker.Stat[ST_MAX_LIFE] / 2)
				{
					AddAttackPlane (nearbyCr, 0, attacker);
				}
			}
			if (relToVictim == REL_HATE && relToAttacker == REL_NEUTRAL)
			{
				// Ну и хер с ним.
			}
			if (relToVictim == REL_HATE && relToAttacker == REL_LIKE)
			{
				if (attacker.Stat[ST_CURRENT_HP] <= attacker.Stat[ST_MAX_LIFE] / 2)
				{
					AddAttackPlane (nearbyCr, 0, victim);
				}
			}
			if (relToVictim == REL_HATE && relToAttacker == REL_IDOL)
			{
				AddAttackPlane (nearbyCr, 0, victim);
			}
			////////////////////////////////////////////////////////////////////2
			/* dislike victim */

			if (relToVictim == REL_DISLIKE && relToAttacker == REL_HATE)
			{
				if (victim.Stat[ST_CURRENT_HP] <= victim.Stat[ST_MAX_LIFE] / 2)
				{
					AddAttackPlane (nearbyCr, 0, attacker);
				}
			}
			if (relToVictim == REL_DISLIKE && relToAttacker == REL_DISLIKE)
			{
				if (victim.Stat[ST_CURRENT_HP] <= victim.Stat[ST_MAX_LIFE] / 4)
				{
					AddAttackPlane (nearbyCr, 0, attacker);
				}
			}
			if (relToVictim == REL_DISLIKE && relToAttacker == REL_NEUTRAL)
			{
				if (victim.Stat[ST_CURRENT_HP] <= victim.Stat[ST_MAX_LIFE] / 10)
				{
					AddAttackPlane (nearbyCr, 0, attacker);
				}
			}
			if (relToVictim == REL_DISLIKE && relToAttacker == REL_LIKE)
			{
				if (attacker.Stat[ST_CURRENT_HP] <= attacker.Stat[ST_MAX_LIFE] / 4)
				{
					AddAttackPlane (nearbyCr, 0, victim);
				}
			}
			if (relToVictim == REL_DISLIKE && relToAttacker == REL_IDOL)
			{
				if (attacker.Stat[ST_CURRENT_HP] <= attacker.Stat[ST_MAX_LIFE] / 2)
				{
					AddAttackPlane (nearbyCr, 0, victim);
				}
			}
			
			////////////////////////////////////////////////////////////////////2
			/* neutral victim */
			
			if (relToVictim == REL_NEUTRAL)
			{
				if (relToAttacker == REL_HATE || relToAttacker == REL_DISLIKE)
				{
					AddAttackPlane (nearbyCr, 0, attacker);
				}
			}
			if (relToVictim == REL_NEUTRAL && relToAttacker == REL_NEUTRAL)
			{
				if (victim.Stat[ST_CURRENT_HP] != victim.Stat[ST_MAX_LIFE])
				{
					AddAttackPlane (nearbyCr, 0, attacker);
				}
			}
			if (relToVictim == REL_NEUTRAL && relToAttacker == REL_LIKE)
			{
				if (victim.Stat[ST_CURRENT_HP] <= victim.Stat[ST_MAX_LIFE] / 2)
				{
					AddAttackPlane (nearbyCr, 0, attacker);
				}
			}
			if (relToVictim == REL_NEUTRAL && relToAttacker == REL_IDOL)
			{
				if (victim.Stat[ST_CURRENT_HP] <= victim.Stat[ST_MAX_LIFE] / 10)
				{
					AddAttackPlane (nearbyCr, 0, attacker);
				}
			}
			
			////////////////////////////////////////////////////////////////////2
			/* like victim */
			
			if (relToVictim == REL_LIKE)
			{
				if (relToAttacker == REL_HATE || relToAttacker == REL_DISLIKE || relToAttacker == REL_NEUTRAL)
				{
					AddAttackPlane (nearbyCr, 0, attacker);
				}
			}
			if (relToVictim == REL_LIKE && relToAttacker == REL_LIKE)
			{
				if (victim.Stat[ST_CURRENT_HP] != victim.Stat[ST_MAX_LIFE])
				{
					AddAttackPlane (nearbyCr, 0, attacker);
				}
			}
			if (relToVictim == REL_LIKE && relToAttacker == REL_IDOL)
			{
				if (victim.Stat[ST_CURRENT_HP] <= victim.Stat[ST_MAX_LIFE] / 4)
				{
					AddAttackPlane (nearbyCr, 0, attacker);
				}
			}
			 
			////////////////////////////////////////////////////////////////////2
			/* idol victim */
			
			if (relToVictim == REL_IDOL)
			{
				if (relToAttacker == REL_HATE || relToAttacker == REL_DISLIKE || relToAttacker == REL_NEUTRAL)
				{
					AddAttackPlane (nearbyCr, 0, attacker);
				}
			}
			if (relToVictim == REL_IDOL && relToAttacker == REL_LIKE)
			{
				if (victim.Stat[ST_CURRENT_HP] != victim.Stat[ST_MAX_LIFE])
				{
					AddAttackPlane (nearbyCr, 0, attacker);
				}
			}
			if (relToVictim == REL_IDOL && relToAttacker == REL_LIKE)
			{
				if (victim.Stat[ST_CURRENT_HP] <= victim.Stat[ST_MAX_LIFE] / 2)
				{
					AddAttackPlane (nearbyCr, 0, attacker);
				}
			}
		
		}
		
		
		//Log ("relToVictim = "+relToVictim+", relToAttacker = "+relToAttacker);
		// Проверяем, в каком отношении относится одна группа к другой. 
	}
	
	/* У групп есть следующие отношения: 
	-- Ненависть
	-- Плохое отношение
	-- Нейтрально
	-- Хорошее отношение
	-- Обожание
	
	/*
	if( cr.IsPlayer() )
        return;                             // Diable player helping
    else
        AddAttackPlane( cr, 0, attacker );  // Answer on attack
    // if(cr.Timeout[TO_AGGRESSOR]>0) return;

    uint helpers = 0;
    uint maxHelpers = 10 - attacker.Stat[ ST_CHARISMA ];
    maxHelpers = CLAMP( maxHelpers, 2, 8 );

    Critter@[] critters;
    cr.GetCritters( true, FIND_LIFE_AND_KO | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        NpcPlane@ plane = critters[ i ].GetCurPlane();
		
        if( valid( plane ) && plane.Type == AI_PLANE_ATTACK && plane.Attack_TargId == attacker.Id )
        {
            helpers++;
            if( helpers >= maxHelpers )
                return;                    // No help needed
            @critters[ i ] = null;         // Exclude this critter
        }
    }

    int  crHpProc = cr.Stat[ ST_CURRENT_HP ] * 100 / cr.Stat[ ST_MAX_LIFE ];
    uint teamId = cr.Stat[ ST_TEAM_ID ];
    uint attackerTeamId = attacker.Stat[ ST_TEAM_ID ];
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        Critter@ someCr = critters[ i ];
        if( not valid( someCr ) )
            continue;                           // Skip excluded

        uint someCrTeamId = someCr.Stat[ ST_TEAM_ID ];
        if( attackerTeamId == someCrTeamId )
            continue;                                         // No attack temmate

		/*
        int teamParity = TEAM_PARITY( someCrTeamId, teamId ); // From -> To
		
		Log ("teamParity = "+teamParity);
        switch( teamParity )
        {
        case Ignore:
            continue;
        case Anyway:
            break;
        case NotBusy:
            if( someCr.IsCurPlane( AI_PLANE_ATTACK ) )
                continue;
            break;
        case HpLess10:
            if( crHpProc >= 10 )
                continue;
            break;
        case HpLess30:
            if( crHpProc >= 30 )
                continue;
            break;
        case HpLess50:
            if( crHpProc >= 50 )
                continue;
            break;
        case IfDead:
            if( not cr.IsDead() )
                continue;
            break;
        case GoodPerson:
            if( attacker.IsNpc() || cr.Stat[ ST_CHARISMA ] < 5 || cr.Stat[ ST_KARMA ] < 0 )
                continue;
            break;
        default:
            continue;
        }

        AddAttackPlane( someCr, 0, attacker );
        helpers++;
        if( helpers >= maxHelpers )
            break;                             // Enough
    }*/
}