// Author: cvet
#include "_macros.fos"
#include "entire.fos"
#include "_msgstr.fos"

import void DropDrugEffects( Critter& cr ) from "drugs";
import void DropPoison( Critter& cr ) from "poison";
import void DropRadiation( Critter& cr ) from "radiation";
import void PlayVideo( Critter& cr, string& videoName, bool canStop ) from "media";


const uint16 startMapPid = MAP_03_01_arroyo_temple_entrance; // тут должна быть стартовая карта
const        uint16[] ReplicatorsMapPids = {  };
uint         ReplicatorPos = 0;


Map@ GetNearReplicatorMap( Critter& cr )
{
    Map@ nearMap = null;
    int  nearDist = 0;
    for( uint i = 0, j = ReplicatorsMapPids.length(); i < j; i++ )
    {
        Map@ map = GetMapByPid( ReplicatorsMapPids[ i ], 0 );
        if( valid( map ) )
        {
            Location@ loc = map.GetLocation();
            int       dx = int(cr.WorldX) - int(loc.WorldX);
            int       dy = int(cr.WorldY) - int(loc.WorldY);
            int       dist = int( sqrt( dx * dx + dy * dy ) );

            if( not valid( nearMap ) || dist < nearDist )
            {
                @nearMap = map;
                nearDist = dist;
            }
        }
    }
    return nearMap;
}

void SetStartLocation( Critter& player ) // Export
{
	uint locId = CreateLocation( LOCATION_StartLocation, 5, 5, null );
    Location @ loc = GetLocation( locId );
    Map @ map = loc.GetMapByIndex( 0 );
    player.TransitToMap( map.Id, ENTIRE_REPLICATION);
	int crType = ( player.Stat[ ST_GENDER ] == GENDER_MALE ? CRTYPE_DW_TRIBAL_M : CRTYPE_DW_TRIBAL_F );
	player.ChangeCrType( crType );
    player.StatBase[ ST_BASE_CRTYPE ] = crType;
	player.StatBase[ST_LAST_MAP_ID] = map.Id;
	
	//GameVar@ trialState = LVAR_arroyo_trial_state
	/*
	
    Map@ replicator = GetMapByPid(startMapPid, 0);
    if( not valid( replicator ) )
        return;

    cr.TransitToMap( replicator.Id, ENTIRE_REPLICATION );
	cr.StatBase[ST_LAST_MAP_ID] = replicator.Id;

    cr.SetKnownLoc( true, replicator.GetLocation().Id );
    uint16 replPid = replicator.GetLocation().GetProtoId();*/
}

void t_StartTemple( Critter& cr, Scenery& trigger, bool entered, uint8 dir )
{
	if (cr.IsPlayer() && entered)
	{
		GameVar@ arroyoTrialState = GetLocalVar( LVAR_arroyo_trial_state, cr.Id );
		if (valid (arroyoTrialState))
		{
			arroyoTrialState = 1;
			
			uint locId = CreateLocation( LOCATION_StartLocation2, 5, 5, null );
			Location @ loc = GetLocation( locId );
			Map @ map = loc.GetMapByIndex( 0 );
			cr.TransitToMap( map.Id, 0);
		}
	}
}

void SetReplicationTime( Critter& cr ) // Export
{
    int replTime = cr.Stat[ ST_REPLICATION_TIME ];
    if( replTime < 0 )
        return;                            // No respawn
    if( replTime == 0 )                    // Take default values
    {
        if( cr.IsPlayer() )
            replTime = 3;                  // 3 minutes
        else
            replTime = Random( 90, 120 );  // 90-120 minutes
    }
    replTime *= REAL_MINUTE( 1 );
    cr.TimeoutBase[ TO_REPLICATION ] = __FullSecond + replTime;
}

void ReplicateCritter( Critter& cr ) // Export
{
	if (cr.IsPlayer())
	{
		ReplicatePlayer (cr);
	}
	else
	{
		//ReplicateNpc (cr);
	}
}

void ReplicatePlayer (Critter& cr)
{
	Map@ map = null;
	GameVar@ arroyoTrialState = GetLocalVar( LVAR_arroyo_trial_state, cr.Id );
	
	// Если еще не прошел испытание, то возрождаем на той же карте. 
	if (valid (arroyoTrialState))
	{
		if (arroyoTrialState.GetValue() < 2)
		{
			@map = GetMap(cr.Stat[ST_LAST_MAP_ID]);
		}
	}
	// Если прошел испытание
	else
	{
		// if () // Если где-то заселился
		
		// Выбрасываем где-то в пустоши. 
		
		// Ну а пока что просто возвращаем туда же, где и был. 
		@map = GetMap(cr.Stat[ST_LAST_MAP_ID]);
	}
	if (valid(map))
	{
		cr.TransitToMap( map.Id, ENTIRE_REPLICATION);
		ReplicateHeal(cr);
	}
	else Log (cr.Id+" испытывает проблемы с репликацией");
}

void ReplicateHeal(Critter& cr)
{
    cr.DamageBase[ DAMAGE_EYE ] = 0;
    cr.DamageBase[ DAMAGE_RIGHT_ARM ] = 0;
    cr.DamageBase[ DAMAGE_LEFT_ARM ] = 0;
    cr.DamageBase[ DAMAGE_RIGHT_LEG ] = 0;
    cr.DamageBase[ DAMAGE_LEFT_LEG ] = 0;
    cr.ToLife();
    cr.StatBase[ ST_CURRENT_HP ] = cr.Stat[ ST_MAX_LIFE ] / 5;
    cr.StatBase[ ST_CURRENT_AP ] = cr.Stat[ ST_ACTION_POINTS ] * 100;
	cr.StatBase[ ST_POISONING_LEVEL ] = 0;
    DropPoison( cr );
    DropRadiation( cr );
	
    cr.DropTimers();
    if( cr.IsNpc() )
	{
        DropDrugEffects( cr );  
	}
    
	for( uint i = TIMEOUT_BEGIN; i <= TIMEOUT_END; i++ )
	{
        if( i != TO_KARMA_VOTING )
		{
            cr.TimeoutBase[ i ] = 0;
		}
	}
}
	
	
	
	/*else
	{
		
		if( cr.IsPlayer() )
		{
			bool customReplMap = false;

			if( customReplMap )
			{
				@map = GetMap( cr.Stat[ ST_NEXT_REPLICATION_MAP ] );
			}
			else
				@map = GetNearReplicatorMap( cr );

			if( not valid( map ) || not GetEntireFreeHex( map, ( customReplMap ? cr.Stat[ ST_NEXT_REPLICATION_ENTIRE ] : ENTIRE_REPLICATION ), hx, hy ) )
			{
				// Continue dead
				cr.TimeoutBase[ TO_REPLICATION ] = __FullSecond + REAL_MINUTE( 1 );
				Log (cr.Id+" испытывает проблемы с репликацией");
				return;
			}

			if( _CritCanDropItemsOnDead( cr ) )
			{
				Map@ dropMap = cr.GetMap();
				Item@[] items;
				cr.GetItems( -1, items );

				// Disable drop of hidden items and delete gag items (sandbags)
				for( uint i = 0, j = items.length(); i < j; i++ )
				{
					if( FLAG( items[ i ].Flags, ITEM_GAG ) )
					{
						DeleteItem( items[ i ] );
						@items[ i ] = null;
					}
					else if( FLAG( items[ i ].Flags, ITEM_HIDDEN ) )
					{
						@items[ i ] = null;
					}
				}

				// Drop
				if( valid( dropMap ) )
					MoveItems( items, dropMap, cr.HexX, cr.HexY );
				else
					DeleteItems( items );
			}
			if( !customReplMap )
			{
				//if( not dieMapIsHell )
				//{
					cr.StatBase[ ST_REPLICATION_MONEY ] -= cr.Stat[ ST_REPLICATION_COST ];
					_CritAddItem( cr, PID_FLOWER, 1 );
					if( cr.Stat[ ST_REPLICATION_MONEY ] >= 100 )
						_CritAddItem( cr, PID_RADIO, 1 );                                                // Add radio
				//}
				cr.StatBase[ ST_REPLICATION_COUNT ]++;
			}
		}
		else
		{
			cr.DropPlanes();
			cr.ClearEnemyStackNpc();
			cr.StatBase[ ST_LAST_WEAPON_ID ] = 0;
			@map = cr.GetMap();
			if( not valid( map ) )     // On global, delete
			{
				DeleteNpc( cr );
				return;
			}
			hx = cr.HexX;
			hy = cr.HexY;

			if( cr.Stat[ ST_DEAD_BLOCKER_ID ] != 0 )
			{
				Item@ block = GetItem( cr.Stat[ ST_DEAD_BLOCKER_ID ] );
				if( valid( block ) )
					DeleteItem( block );
				cr.StatBase[ ST_DEAD_BLOCKER_ID ] = 0;
			}

			if( not map.IsHexPassed( hx, hy ) )
			{
				bool founded = false;
				for( int x = -1; x <= 1; x++ )
				{
					for( int y = -1; y <= 1; y++ )
					{
						if( x == 0 && y == 0 )
							continue;                                  // Skip direct position

						if( __MapHexagonal )
						{
							if( ( hx % 2 ) == 1 && ( ( x == -1 && y == 1 ) || ( x == 1 && y == 1 ) ) )
								continue;
							if( ( hx % 2 ) == 0 && ( ( x == -1 && y == -1 ) || ( x == 1 && y == -1 ) ) )
								continue;
						}

						if( map.IsHexPassed( hx + x, hy + y ) )
						{
							hx += x;
							hy += y;
							founded = true;
							break;
						}
					}
					if( founded )
						break;
				}

				if( not founded )
				{
					// Continue dead
					cr.TimeoutBase[ TO_REPLICATION ] = __FullSecond + REAL_MINUTE( 1 );
					return;
				}
			}
		}
	}*/
	/*
    cr.TransitToMap( map.Id, hx, hy, Random( 0, 5 ) );
    cr.DamageBase[ DAMAGE_EYE ] = 0;
    cr.DamageBase[ DAMAGE_RIGHT_ARM ] = 0;
    cr.DamageBase[ DAMAGE_LEFT_ARM ] = 0;
    cr.DamageBase[ DAMAGE_RIGHT_LEG ] = 0;
    cr.DamageBase[ DAMAGE_LEFT_LEG ] = 0;
    if( cr.Stat[ ST_NEXT_CRTYPE ] > 0 )
    {
        cr.ChangeCrType( cr.Stat[ ST_NEXT_CRTYPE ] );
        cr.StatBase[ ST_BASE_CRTYPE ] = cr.Stat[ ST_NEXT_CRTYPE ];
        cr.StatBase[ ST_NEXT_CRTYPE ] = 0;
    }
    cr.ToLife();
    cr.StatBase[ ST_CURRENT_HP ] = cr.Stat[ ST_MAX_LIFE ];
    cr.StatBase[ ST_CURRENT_AP ] = cr.Stat[ ST_ACTION_POINTS ] * 100;
    DropPoison( cr );
    DropRadiation( cr );
    if( cr.IsNpc() )
        DropDrugEffects( cr );                                              // Note: This function clear effects of all active drugs/radiation/poison!
    cr.DropTimers();
    for( uint i = TIMEOUT_BEGIN; i <= TIMEOUT_END; i++ )
        if( i != TO_KARMA_VOTING )
            cr.TimeoutBase[ i ] = 0;
}
*/

//
// Hubologist
//
void _HubologistInit( Critter& hubologist, bool firstTime )
{
    hubologist.ModeBase[ MODE_NO_ENEMY_STACK ] = 1;
}
