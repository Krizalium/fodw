// Author: cvet
#include "_macros.fos"
#include "_msgstr.fos"
#include "_teams.fos"
#include "_npc_pids.fos"
#include "_animation.fos"
#include "teams_table.fos"
#include "logger.fos"
#include "relationship.fos"

// Раздробление main
#include "main_start.fos"
#include "main_critter_attacked.fos"
#include "main_critter_use_item.fos"
#include "main_critter_use_skill.fos"
#include "main_critter_reload_weapon.fos"
#include "main_critter_init.fos"
#include "main_critter_dead.fos"
#include "main_player_allowcommand.fos"


// Imports
import void InitializeGame() from "config";
import bool OnUseExplode( Critter& cr, Item& explode, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen, uint timer ) from "explode";
import bool UseItemOnCar( Critter& cr, Item& car, Item& item ) from "car";
import bool UseSkillOnCar( Critter& cr, Item& car, int skill ) from "car";
import void SetStartLocation( Critter& cr ) from "replication";
import void SetReplicationTime( Critter& cr ) from "replication";
import void ReplicateCritter( Critter& cr ) from "replication";
import void CombatAttack( Critter& cr, Critter& target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo ) from "combat";
import bool TryRepairItem( Critter& cr, Item& item ) from "repair";
import bool IsReadableBook( uint16 pid ) from "books";
import void TryReadBook( Critter& cr, Item& book ) from "books";
import void UseDrug( Critter& cr, Item& drug ) from "drugs";
import void UseDrugOn( Critter& cr, Critter& onCr, Item& drug ) from "drugs";
import bool UseGeiger( Critter& cr, Item& geiger ) from "geiger";
import bool UseItemOnGeiger( Critter& cr, Item& geiger, Item& item ) from "geiger";
import bool UseSkillOnGeiger( Critter& cr, Item& geiger, int skill ) from "geiger";
import bool AddAttackPlane( Critter& npc, uint priority, Critter& target ) from "npc_planes";
import bool AddAttackPlane( Critter& npc, uint priority, Critter& target, int minHp ) from "npc_planes";
import bool UseSkillOnLocker( Critter& cr, Item& locker, int skill ) from "lockers";
import bool PerkCheck( Critter& cr, uint perk ) from "perks";
import void CritterGenerate( Critter& cr ) from "parameters";
import int  GetDeteriorationProcent( Item& item ) from "repair";
import void SetDeterioration( Item& item, int deteriorationProcent ) from "repair";
import void NpcProcessLevel( Critter& npc ) from "parameters";
import void EditRadioSettings( Critter& player, Item& radio ) from "radio";
import bool BarterAllowed( int crId, Item@[]& buyItems,  Item@[]& saleItems ) from "limited_barter";
import uint CheckPlayerName( const string& name ) from "parameters";
import bool ProtoItem_Weapon_IsHtHAttack( ProtoItem& proto, uint8 mode ) from "parameters";

import void GenerationInit() from "generation";
import void SaveGenerationResources() from "generation";
import void MobSystemInit() from "mob_system";

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called before world generation.
void init()
{
    InitializeGame();
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on start server.
bool start()
{
	main_start();
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on world initialization.
// Parameter         Min    Max
// multiplier        1      50000
// year              1700   30000
// month             1      12
// day               1      31
// hour              0      23
// minute            0      59
void get_start_time( uint16& multiplier, uint16& year, uint16& month, uint16& day, uint16& hour, uint16& minute )
{
    multiplier = 20;
    year = 2241;
    month = 9;
    day = 27;
    hour = 12;
    minute = 0;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on finish server.
void finish()
{}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call every returned value, in milliseconds.
// Return next call in milliseconds or zero to disable loop.
uint loop()
{
    return 0;     // Disable
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter attack another.
void critter_attack( Critter& cr, Critter& target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo )
{
    cr.TimeoutBase[ TO_AGGRESSOR ] = __FullSecond + REAL_MINUTE( 1 );
    CombatAttack( cr, target, weapon, weaponMode, ammo );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter attack another.
void critter_attacked( Critter& cr, Critter& attacker )
{
    main_critter_attacked (cr, attacker);
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter steal another.
bool critter_stealing( Critter& cr, Critter& thief, Item& item, uint count )
{
    return false;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter use item.
bool critter_use_item( Critter& cr, Item& item, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen, uint param )
{
    return main_critter_use_item (cr, item, targetCr, targetItem, targetScen, param);
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter use skill.
bool critter_use_skill( Critter& cr, int skill, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen )
{
	return main_critter_use_skill (cr, skill, targetCr, targetItem, targetScen);
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter reload weapon.
// If ammo is not valid than only unload.
void critter_reload_weapon( Critter& cr, Item& weapon, Item@ ammo )
{
    main_critter_reload_weapon (cr, weapon, ammo);
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on player register/login in game or npc created/loaded.
// Default start position for players is center of global map.
void critter_init( Critter& cr, bool firstTime )
{
	main_critter_init(cr, firstTime);
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on critter exit from game.
void critter_finish( Critter& cr, bool toDelete )
{
    if( toDelete && cr.Stat[ ST_DEAD_BLOCKER_ID ] != 0 )
    {
        Item@ block = ::GetItem( cr.Stat[ ST_DEAD_BLOCKER_ID ] );
        if( valid( block ) )
            DeleteItem( block );
        cr.StatBase[ ST_DEAD_BLOCKER_ID ] = 0;
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call every __CritterIdleTick time.
void critter_idle( Critter& cr )
{
	Map@ map = cr.GetMap();
	if (!valid (map))
	{
		Map @oldMap = GetMap(cr.Stat[ST_LAST_MAP_ID]);
		if (valid (oldMap))
		{
			cr.TransitToMap(cr.Stat[ST_LAST_MAP_ID], 0);
		}
		else // Подразуемваем, что игрока дропнуло со стартовой локации на глобалку. 
		{ // SetStartLocation
			GameVar@ arroyoTrialState = GetLocalVar( LVAR_arroyo_trial_state, cr.Id );
			if (valid (arroyoTrialState))
			{
				if (arroyoTrialState.GetValue() < 2)
				{
					SetStartLocation(cr);
				}
				else
				{
					Log (cr.Id+" попал в беду");
				}
			}
		}
	}
	if (cr.IsDead() && cr.IsPlayer())
	{
		GameVar@ arroyoTrialState = GetLocalVar( LVAR_arroyo_trial_state, cr.Id );
		if (valid (arroyoTrialState))
		{
			if (arroyoTrialState.GetValue() < 2)
			{
				ReplicateCritter(cr);
			}
		}
	}
	
    if( cr.IsDead() && cr.Stat[ ST_REPLICATION_TIME ] >= 0 && cr.Timeout[ TO_REPLICATION ] == 0 )
        ReplicateCritter( cr );

    // Healing
    if( cr.Timeout[ TO_HEALING ] == 0 )
    {
        if( !cr.IsDead() && cr.Mode[ MODE_NO_HEAL ] == 0 && cr.StatBase[ ST_CURRENT_HP ] < cr.Stat[ ST_MAX_LIFE ] && cr.Stat[ST_POISONING_LEVEL] == 0)
        {
            cr.StatBase[ ST_CURRENT_HP ] += cr.Stat[ ST_HEALING_RATE ] * ( cr.Perk[ PE_VAMPIRE_REGENERATION ] > 0 ? 2 : 1 );
            if( cr.StatBase[ ST_CURRENT_HP ] > cr.Stat[ ST_MAX_LIFE ] )
                cr.StatBase[ ST_CURRENT_HP ] = cr.Stat[ ST_MAX_LIFE ];
        }

        cr.TimeoutBase[ TO_HEALING ] = HEALING_TIMEOUT( cr );
    }
	
	// new Poison by Kriz:
	
	#define STR_POISON_PROCESS      ( 12811 )
	if (cr.Stat[ST_POISONING_LEVEL] > 0)
	{
		// target.Action( ACTION_DAMAGE, attackFront ? 0 : 1, null );
		cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_POISON_PROCESS );
        cr.StatBase[ ST_CURRENT_HP ] -= cr.Stat[ST_POISONING_LEVEL];
		
		cr.StatBase[ST_POISONING_LEVEL]-=1;
        if(cr.Stat[ ST_CURRENT_HP ] <= 0)
		{
            cr.ToDead( Random( 0, 1 ) == 0 ? ANIM2_DEAD_FRONT : ANIM2_DEAD_BACK, null );
		}
		else
		{
			cr.Action( ACTION_DAMAGE, Random(0,1), null );
		}
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter dies.
// Killer can be null.
void critter_dead( Critter& cr, Critter@ killer )
{
    main_critter_dead(cr, killer);
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter reswapned.
void critter_respawn( Critter& cr )
{
    if( cr.Stat[ ST_DEAD_BLOCKER_ID ] != 0 )
    {
        Item@ block = ::GetItem( cr.Stat[ ST_DEAD_BLOCKER_ID ] );
        if( valid( block ) )
            DeleteItem( block );
        cr.StatBase[ ST_DEAD_BLOCKER_ID ] = 0;
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter in to map.
void map_critter_in( Map& map, Critter& cr )
{
    if (cr.IsPlayer())
    {
		uint16 mapId = map.Id;
		cr.StatBase[ST_LAST_MAP_ID] = mapId;
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter out from map.
void map_critter_out( Map& map, Critter& cr )
{
    if (cr.IsPlayer())
    {
		if (!valid(cr.GetMap()))
		{
			Log (cr.Id+" вышел на глобальную карту.");
		}
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something player votes for another.
// Already checked valid positions and timeout.
void karma_voting( Critter& crFrom, Critter& crTo, bool valUp )
{
    // Players karma system (not used)
    crTo.StatBase[ ST_PLAYER_KARMA ] += ( valUp ? int(5) : -10 );
    crFrom.TimeoutBase[ TO_KARMA_VOTING ] = __FullSecond + REAL_HOUR( 4 ); // 4 hours

/*	// Good / Evil system (not used)
        crFrom.TimeoutBase[TO_KARMA_VOTING]=__FullSecond+60; // Some small time to prevent bruteforce
        int crId=int(crTo.Id);
        // Find alredy added
        for(uint i=GOOD_EVIL_LIST_BEGIN;i<=GOOD_EVIL_LIST_END;i++)
        {
                int id=crFrom.GoodEvilList[i];
                if(id!=0)
                {
                        bool isEvil=FLAG(id,0x80000000);
                        if(isEvil) id^=0x80000000;

                        if(id==crId)
                        {
                                if((valUp && not isEvil) || (not valUp && isEvil)) return; // Already added
                                crFrom.GoodEvilListBase[i]=0; // Erase from list
                                return;
                        }
                }
        }
        // Add new record
        if(not valUp) crId|=0x80000000;
        for(uint i=GOOD_EVIL_LIST_BEGIN;i<=GOOD_EVIL_LIST_END;i++)
        {
                int id=crFrom.GoodEvilList[i];
                if(id==0)
                {
                        crFrom.GoodEvilListBase[i]=crId;
                        return;
                }
        }
        // All places busy, erase first 10
        for(uint i=GOOD_EVIL_LIST_BEGIN;i<=GOOD_EVIL_LIST_END-10;i++) crFrom.GoodEvilListBase[i]=crFrom.GoodEvilListBase[i+10];
        for(uint i=GOOD_EVIL_LIST_END-9;i<=GOOD_EVIL_LIST_END;i++) crFrom.GoodEvilListBase[i]=0;
        crFrom.GoodEvilListBase[GOOD_EVIL_LIST_END-10]=crId;*/
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine visibility of critters.
// To start working set flag LOOK_CHECK_SCRIPT to __LookChecks global var.
// Return true to allow see one critter another, false to disallow.
// Note: CRITTER_EVENT_SHOW_CRITTER_X, CRITTER_EVENT_HIDE_CRITTER_X is not processed.
bool check_look( Map& map, Critter& cr, Critter& opponent )
{
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine visibility of items with ITEM_TRAP flag.
// To start working set flag LOOK_CHECK_SCRIPT to __LookChecks global var.
bool check_trap_look( Map& map, Critter& cr, Item& trap )
{
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine cost of single item.
// To allow function set __CustomItemCost to true.
// Don't forgot specify this function in client script.
uint item_cost( Item& item, Critter& cr, Critter& npc, bool sell )
{
    return sell ? 1 : 2;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on barter transaction.
// Return false to cancel transaction.
bool items_barter( Item@[]& saleItems, uint[]& saleItemsCount, Item@[]& buyItems, uint[]& buyItemsCount, Critter& player, Critter& npc )
{
    if( npc.Mode[ MODE_BARTER_ONLY_CASH ] > 0 )
    {
        for( uint i = 0, j = saleItems.length(); i < j; i++ )
        {
            Item@ item = saleItems[ i ];
            if( valid( item ) && item.GetProtoId() != PID_BOTTLE_CAPS )
            {
                npc.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_BARTER_ONLY_CASH );
                npc.SayMsg( SAY_DIALOG, TEXTMSG_GAME, STR_BARTER_ONLY_CASH );
                return false;
            }
        }
    }

    if( !BarterAllowed( npc.Id, buyItems, saleItems ) )
    {
        npc.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_BARTER_ITEM_NOT_ALLOWED );
        return false;
    }

    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something player craft some items.
// Resources have None accessory and will be deleted after this function if no will be added to some place.
void items_crafted( Item@[]& items, uint[]& itemsCount, Item@[]& resources, Critter& crafter )
{
    // Find max deterioration value
    int maxDeterioration = 0;
    for( uint i = 0, j = resources.length(); i < j; i++ )
    {
        Item@ item = resources[ i ];
        int   deterioration = GetDeteriorationProcent( item );
        if( deterioration > maxDeterioration )
            maxDeterioration = deterioration;
    }

    for( uint i = 0, j = items.length(); i < j; i++ )
    {
        // Unload weapons
        Item@ item = items[ i ];
        if( item.GetType() == ITEM_TYPE_WEAPON && item.Proto.Weapon_MaxAmmoCount > 0 )
        {
            item.AmmoCount = 0;
            item.Update();
        }

        // Set max deterioration value
        SetDeterioration( item, maxDeterioration );
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Levelup callback.
void player_levelup( Critter& player, uint skillIndex, uint skillUp, uint perkIndex )
{/*
    if( skillIndex >= SKILL_BEGIN && skillIndex <= SKILL_END )
    {
        for( ; skillUp != 0; skillUp-- )
        {
            int skillVal = player.SkillBase[ skillIndex ];
            if( skillVal >= MAX_SKILL_VAL )
                break;

            int needPoints = 1;
            if( skillVal > __SkillModAdd6 )
                needPoints = 6;
            else if( skillVal > __SkillModAdd5 )
                needPoints = 5;
            else if( skillVal > __SkillModAdd4 )
                needPoints = 4;
            else if( skillVal > __SkillModAdd3 )
                needPoints = 3;
            else if( skillVal > __SkillModAdd2 )
                needPoints = 2;

            if( player.StatBase[ ST_UNSPENT_SKILL_POINTS ] < needPoints )
                break;

            skillVal++;
            if( _CritIsTagSkill( player, skillIndex ) && skillVal < MAX_SKILL_VAL )
                skillVal++;
            player.SkillBase[ skillIndex ] = skillVal;
            player.StatBase[ ST_UNSPENT_SKILL_POINTS ] -= needPoints;
        }
    }*/
    /*else*/ if( perkIndex >= PERK_BEGIN && perkIndex <= PERK_END )
    {
        if( PerkCheck( player, perkIndex ) )
        {
            player.PerkBase[ perkIndex ]++;
            player.StatBase[ ST_UNSPENT_PERKS ]--;
        }
    }

    player.StatBase[ ST_REPLICATION_COST ] = player.Stat[ ST_LEVEL ] * 100;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Turn based callbacks.
// Called on every round begin, return false to disable turn-based
void turn_based_begin( Map& map )
{
    // Try end battle
    if( map.TurnBasedRound > 0 )
    {
        uint[] crittersIds;
        map.GetTurnBasedSequence( crittersIds );

        bool continueBattle = false;
        if( crittersIds.length() >= 2 )
        {
            for( uint i = 0, j = crittersIds.length(); i < j; i++ )
            {
                Critter@ cr = ::GetCritter( crittersIds[ i ] );
                if( !( not valid( cr ) || cr.IsDead() ||
                       ( cr.IsNpc() && cr.GetPlanes( AI_PLANE_ATTACK, null ) == 0 ) ||
                       ( cr.IsPlayer() && ( cr.Mode[ MODE_END_COMBAT ] != 0 || cr.Stat[ ST_CURRENT_HP ] < 1 ) ) ) )
                {
                    continueBattle = true;
                    break;
                }
            }
        }

        if( not continueBattle )
            map.EndTurnBased();
    }
}

// Call on end turn-based battle
void turn_based_end( Map& map )
{
    //
}

// Call on every begin and end turn
void turn_based_process( Map& map, Critter& cr, bool beginTurn )
{
    if( beginTurn )
    {
        cr.StatBase[ ST_MOVE_AP ] = cr.Stat[ ST_MAX_MOVE_AP ];
        cr.StatBase[ ST_TURN_BASED_AC ] = 0;
    }
    else
    {
        bool hthEvade = false;
        if( cr.Perk[ PE_HTH_EVADE ] != 0 )
        {
            // In hands only HtH weapons
            Item@ hand1 = cr.GetItem( 0, SLOT_HAND1 );
            Item@ hand2 = cr.GetItem( 0, SLOT_HAND2 );
            if( ( not valid( hand1 ) || hand1.GetType() != ITEM_TYPE_WEAPON || not ProtoItem_Weapon_IsHtHAttack( hand1.Proto, 0 ) ) &&
                ( not valid( hand1 ) || hand1.GetType() != ITEM_TYPE_WEAPON || not ProtoItem_Weapon_IsHtHAttack( hand1.Proto, 0 ) ) )
            {
                hthEvade = true;
            }
        }

        cr.StatBase[ ST_TURN_BASED_AC ] = cr.Stat[ ST_CURRENT_AP ] * ( hthEvade ? 2 : 1 );
        if( cr.Stat[ ST_TURN_BASED_AC ] < 0 )
            cr.StatBase[ ST_TURN_BASED_AC ] = 0;
        if( hthEvade && cr.Skill[ SK_UNARMED ] > 0 )
            cr.StatBase[ ST_TURN_BASED_AC ] += cr.Skill[ SK_UNARMED ] / 12;
        cr.StatBase[ ST_MOVE_AP ] = 0;
    }
}

// Call when need generate turns sequence
void turn_based_sequence( Map& map, Critter@[]& critters, Critter@ firstTurnCrit )
{
    // Check first turn critter
    if( valid( firstTurnCrit ) && ( firstTurnCrit.IsDead() || firstTurnCrit.Stat[ ST_CURRENT_AP ] <= 0 ) )
        @firstTurnCrit = null;

    // Collect critters
    SequenceCritter[] sequenceCritters;
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        Critter@ cr = critters[ i ];
        if( valid( firstTurnCrit ) && firstTurnCrit.Id == cr.Id )
            continue;
        if( cr.IsDead() )
            continue;
        sequenceCritters.resize( sequenceCritters.length() + 1 );
        @sequenceCritters.last().critter = cr;
    }

    // Sort sequence, see SequenceCritter::opCmp below
    SequenceCritterRandom = Random( 0, 1 );
    sequenceCritters.sortDesc();

    // Fill result
    critters.resize( 0 );
    if( valid( firstTurnCrit ) )
        critters.insertLast( firstTurnCrit );
    for( uint i = 0, j = sequenceCritters.length(); i < j; i++ )
        critters.insertLast( sequenceCritters[ i ].critter );
}

// Sequence sorter for turn_based_sequence
int   SequenceCritterRandom = 0;
class SequenceCritter
{
    Critter@ critter;
    int opCmp( SequenceCritter& in other )
    {
        bool     result;
        Critter@ cr1 = critter;
        Critter@ cr2 = other.critter;
        int      seq1 = cr1.Stat[ ST_SEQUENCE ];
        int      seq2 = cr2.Stat[ ST_SEQUENCE ];
        if( seq1 == seq2 )
        {
            int ag1 = cr1.Stat[ ST_AGILITY ];
            int ag2 = cr2.Stat[ ST_AGILITY ];
            if( ag1 == ag2 )
            {
                int lk1 = cr1.Stat[ ST_LUCK ];
                int lk2 = cr2.Stat[ ST_LUCK ];
                if( lk1 == lk2 )
                {
                    if( SequenceCritterRandom == 0 )
                        result = cr1.Id > cr2.Id;
                    else
                        result = cr1.Id < cr2.Id;
                }
                else
                    result = lk1 > lk2;
            }
            else
                result = ag1 > ag2;
        }
        else
            result = seq1 > seq2;
        return result ? int(1) : int(-1);
    }
}

// Call on world saving
// Range of currentIndex: 1..9999
void world_save( uint currentIndex, uint[]& deleteIndexes )
{
    // Keep only current and four last saves
    if( currentIndex == 1 )
    {
        deleteIndexes.resize( 5 );
        for( uint i = 0; i < 5; i++ )
            deleteIndexes[ i ] = 9999 - i;
    }
    else if( currentIndex > 4 )
    {
        deleteIndexes.resize( 1 );
        deleteIndexes[ 0 ] = currentIndex - 5;
    }
	
	SaveGenerationResources();
}

// Call on player try register
// Return true to allow, false to disallow
bool player_registration( uint ip, string& name, uint& textMsg, uint& strNum, string& lexems )
{
    uint nameError = CheckPlayerName( name );
    if( nameError != 0 )
    {
        textMsg = TEXTMSG_GAME;
        strNum = nameError;
        return false;
    }
    return true;
}

// Call on player try login
// Return true to allow, false to disallow
bool player_login( uint ip, string& name, uint id, uint& textMsg, uint& strNum, string& lexems )
{
	string[] params = {name, ""+ip, ""+id};
	AddLog(LOG_TYPE_LOGIN, params);
	
    return true;
}

// Call on player try change access
// Return true to allow, false to disallow
bool player_getaccess( Critter& player, int access, string& password )
{
    Log( "Access changed for player " + player.Name + ", from " + player.GetAccess() + " to " + access + "." );
    return true;
}

bool player_allowcommand( Critter@ player, string@ adminPanel, uint8 command )
{
	return main_player_allowcommand (player, adminPanel, command);
}
